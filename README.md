# 안익수 202030318

## 새로운 내용은 위에 작성
## 추가내용 

## 2024-06-11 강의 내용 

### Specialization(특수화, 전문화)
- 웰컴다이얼로그는 다이얼로그의 특별한 케이스임.
- 범용적인 개념을 구별이 되게 구체화하는 것을 특수화라고 함
- 객체지향 언어에서는 상속을 사용하여 특수화를 구현함 
- 리액트에서는 합성을 사용하여 특수화를 구현함 

### Containment와 Specialization을 같이 사용하기
- Containment를 위해서 props.childern을 사용하고 Specialization을 위해 직접 정의한 props를 사용하면 됨
- Dialog컴포넌트는 이전의 것과 비슷한데 Containment를 위해 끝부분에 props.children을 추가함
- Dialog를 사용하는 SignUpDialogsms Specialization을 우ㅏ해 props인 title,message에 값을 넣어주고 있고,입력을 받기위해 `<input>` 과 `<button>`을 사용함
- 이러한 형태로 Containment와 Specialization을 동시에 사용할 수 있음

### 상속에 대해 알아보기
- 합성과 대비되는 개념으로 상속이 있음
- 자식 클래스는 부모 클래스가 가진 변수나 함수 등의 속성을 모두 갖게 되는 개념
- 리액트에서는 상속보다는 합성을 통해 새로운 컴포넌트를 생성함

### 합성기법
- Containment
- Specailization
 

### 컨텍스트란 무엇인가?
- 기존의 일반적인 리액트에서는 데이터가 컴포넌트의 props를통해 부모에서 자식으로 단방향으로 전달됨
- 컨텍스트는 리액트 컴포넌트들 사이에서 데이터를 기존의 props를 통해 전달하는 방식 대신 컴포넌트 트리를 통해 곧바로 컴포넌트에 전달하는 새로운 방식을 제공
- 이 것을 통해 어떤 컴포넌트라도 쉽게 데이터에 접근 할 수 있음
- 컨텍스트를 사용하면 일일이 props로 전달할 필요없이 데이터를 필요로 하는 컴포넌트에 곧바로 데이터를 전달할 수 있음

### 언제 컨텍스트를 사용해야 할까?
- 여러 컴포넌트에서 자주 필요로 하는 데이터는 로그인 여부, 로그인 정보, UI테마 , 현재 선택된 언어등이 있음
- props를 통해 데이터를 전달하는 기존 방식은 실제 데이터를 필요로 하는 컴포넌트까지의 깊이가 깊어질 수록 복잡래짐
- 반복적인 코드를 계속해서 작성해 주어야 하기 떄문에 비효율적이고 가독성이 떨어짐
- 컨텍스트를 사용하면 이러한 방식을 깔끔하게 개선할 수 있음
- `React.createContext()`함수를 사용함
### 컨텍스트를 사용하기전에 고려할 점
- 컨텍스트는 다른 레벨의 많은 컴포넌트가 특정 데이터를 필요로 하는 경우에 주로 사용
- 하지만 무조건 컨텍스트를 사용하는 것이 좋은것은 아님
- 왜냐면 컴포넌트와 컨텍스트가 연동되면 재사용성이 떨어짐
- 따라서 다른 레벨의 많은 컴포넌트가 데이터를 필요로 하는 경우가 아니면 props를 통해 데이터를 전달하는 컴포넌트 합성 방법이 더 적합함
- 하지만 어떠한 경우에는 하나의 데이터에 다양한 레벨에 있는 중첩된 컴포넌트들의 접근이 필요할 수 있음
- 컨텍스트는 해당 데이터와 데이터의 변경사항을 모두 하위 컴포넌트들에게 broadcast해주기 때문
- 컨텍스트를 사용하기에 적합한 데이터의 대표적인 예로는 지역정보 ui테마 그리고 캐싱된 데이터 등이 있음
### 컨텍스트 API

1. React.createContext
    - 컨텍스트를 생성하기 위한 함수
    - 파마리터에는 기본값을 넣어줌
    - 하위 컴포넌트는 가장 가까운 상위 레벨의 provider로 부터 컨텍스트를 받게 더ㅚ지만 만일 Provider를 찾을 수 없다면 아래에서 설정한 기본값을 사용하게 됨
    - ``` const MyContext = React.createContext(기본값)```
2. Context.Provider
    - Context.Provider컴포넌트로 하위 컴포넌트들을 감싸주면 모든 하위 컴포넌트들이 해당 컨텍스트의 데이터에 접근할 수 있게 됨  
    - ``` <MyContext.Provider value={/* some value */}>```  
    - provider 컴포넌트에는 value라는 prop이 있고 이것은 Provider컴포넌트 하위에 있는 컴포넌트에게 전달됨
    - 하위 컴포넌트를 consumer컴포넌트라고 부름.

3. Class.contextType
    - provider하위에 있는 클래스 컴포넌트에서 컨텍스트의 데이터에 접근하기 위해 사용함.
    - Class컴포넌트는 더이상 사용하지 않으므로 참고만 함
4. Context.Consumer
    - 함수형 컴포넌트에서 Context.Consumer를 사용하여 컨텍스트를 구독 할 수 있음
5. Context.displayName
    - 컨텍스트 객체는 displayName이라는 문자열 속성을 갖음
    - 크롬의 리액트 개발자 도구에서는 컨텍스트의 provider나 consumer를 표시할 떄 displayName을 함께 표시해줌    
    ```
    const Mycontext = react.createContext
        Mycontext.displayName = 'MydisplayName'
    <MyContext.Provider>
    ```

### 여러개의 컨텍스트 사용하기
- 여러개의 컨텍스트를 동시에 사용하려면 Context.Provider를 사용함   


### useContext
- 함수형 컴포넌트에서 컨텍스트를 사용하기 위해 컴포넌트를 매번 Consumer컴포넌트로 감싸주는 것보다 더 좋은 방법이 있음
- useContext() 훅은 React.createContext() 함수 호출로 생성된 컨텍스트 객체를 인자로 받아서 현재 컨텍스트의 값을 리턴함.
- 만일 값이 변경되면 useContext() 훅은 사용하는 컴포넌트가 재 렌더링 됨
- 또한 useContext() 훅을 사용할 때에는 파라미터로 컨텍스트 객체를 넣어줘여 한다는 것을 기억 해야 함

## 2024-06-05 강의 내용

### 합성에 대해 알아보기
- 합성은 여러개의 컴포넌트를 합쳐서 새로운 컴포넌트를 만드는 것임
- 조합 방법애 따라 합성의 사용 기법은 다음과 같이 나눌 수 있음

#### Containment
- 특정 컴포넌트가 하위 컴포넌트를 포함하는 형태의 합성 방법
- 컴포넌틍 따라서 어떤 자식 엘리먼트가 들어올 지 미리 예상할 수 없는 경우가 있음
- 범용적인 박스 역할을 하는 sidebar혹은 dialog와 같은 컴포넌트에서 특히 자주 볼 수 있음
- 이런 컴포넌트에서는 childrenprop을 사용하여 자식 엘리먼트를 출력에 그대로 전달하는것이 좋음 
- 이때 children prop은 컴포넌트의 props에 기본적으로 들어있는 children속성을 사용함 

### Shared State적용하기
- 다음은 하위 컴포넌트의 state를 부모 컴포넌트로 올려서 sared state를 적용함 
- 두 컴포넌트를 조정하고 싶을 때 state를 그들의 공통 부모로 이동함 
- 입력 값이 변경되었을 떄 상위 컴포넌트로 변경된 값을 전달해 주어야 함 
- 그리고 공통 부모로부터 props를 통해 정보를 전달함
- 마지막으로 이벤트 핸들러를 전달해 자식에서 부모의 state를 변경할 수 있도록 함
- 컴포넌트를 (props로부터) “제어”할지 (state로부터) “비제어” 할지 고려하면 유용함



## 2024-05-29 강의 내용

### File input태그
- file input 태그는 그 값이 일기 전용이기 때문에 리액트에서는 비제어 컴포넌트가 됨

### Input Null Value
* 제어 컴포넌트애 value prop을 정해진 값으로 넣으면 코드를 수정하지 않는 한 입력값을 바꿀 수 없음  
* 만약 value prop은 넣되 자유롭게 입력할 수 있게 만들고 싶다면 값이 undefined 또는 null을 넣어주면 됨  

## 2024-05-22 강의 내용

### 제어 컴포넌트 
    제어 컴포넌트는 사용자가 입력한 값에 접근하고 제어할 수 있도록 해주는 컴포넌트 임

### 리스트와 키란 무엇인가?
    1. 리스트는 자바스크립트의 변수나 객체를 하나의 변수로 묶어 놓은 배열과 같은 것임
    2. 키는 각 객체나 아이템을 구분할 수 있는 고유한 값을 의미함.
    3. 리액트에서는 배열과 키를 사용하는 반복되는 다수의 엘리먼트를 쉽게 렌더링 할 수있음

* 리스트에서의 키는 "리스트 에서 아이템을 구별하기 위한 고유한 문자열" 이다
* 이 키는 리스트에서 어떤 아이템이 변경,추가 또는 제거되었는지 구분하기 위해 사용함 
- 키는 같은 리스트에 있는 엘리언트 사이에서만 고유한 값이면 됨
### 여러 개의 컴포넌트 렌더링하기
    예의 에어비엔비의 화면처럼 같은 컴포넌트를 화면에 반복적으로 나타내야 할 경우 배열에 들어 있는 엘리먼트를 map()함수를 이용하여 렌더링 함 

```
const doubled = numbers.map((number) => number * 2); 
```
      



## 2024-05-08 강의 내용
### 이벤트 처리하기

```
<button onclick= 'activate()'> 
    Activate
</button>
```
onclick 속성에는 activate()라는 문자열이 포함되어 있음
```
<button onclick= {activate}>
    Activate
 </button>
```
onclick 속성에는 activate라는 함수의 참조가 직접 포함되어 있음

* 클래스형 컴포넌트는 코드 안에 라이프사이클 기능과 state 기능이 구현이 가능함 
* 함수형 컴포넌트는 hook을 사용하여 라이프사이클 기능과 state 기능을 구현할 수 있음 


### Arguments 전달하기
- 함수를 정의할 때는 파라미터 혹은 매개변수,함수를 사용할 때는 아귀먼트 혹은 인수라고 부름.
- 이벤트 핸들러에 매개변수를 전달해야 하는 경우도 많음
```
1. <button onClick={(event)=> this,deleteItem(id,event)}>삭제하기</button>  
2. <button onClick={this,deleteItem.bind(this,id)}>삭제하기</button>
```
- 위의코드는 모두 동일한 역할 을 하지만 하나는 화살표 함수를 다른하나는 bind를 사용함  
-  두 방법 모두 첫 번쨰 매개변수는 id이거ㅗ 두번쨰 매개변수로 event가 전달 됨

### 인라인 조건
- 필요한 곳에 조건문을 직접 넣어 사용하는 방법임.
1. 인라인 if  
    if문을 직접 사용하지 않고, 동일한 효과를 내기위해 && 논리 연산자를 사용함
2. &&는 and 연산자로 모든 조건이 참일때만 참이 됨.  
3. 첫 번 조건이 거짓이면 두번째 조건은 판단할 필요가 없음.

4. 인라인 if-else
    
## 2024-05-01 강의 내용
### 훅의 규칙
* 첫 번쨰 규칙은 무조건 최상위 레벨에서만 호출해야 한다는 것임.  
* 따라서 반복문이나 조건문 또는 중첩된 함수들 안에서 훅을 호출하면 안 됨.  
* 아 규칙에 따라서 훅운 컴포넌트가 렌더링 될 때마다 같은 순서로 호출되어야 함. 
* 두 번쨰 규칙은 함수형 컴포넌트에서만 훅을 호출해야 한다는 것임
* 따라서 일반 자바스크립트 함수에서 훅을 호출하면 안됨.
* 훅은 함수형 컴포넌트 혹은 직접 만든 커스텀 훅에서만 호출할 수 있음.


### 커스텀 훅 
* 반복되는 로직을 리액트 내장 훅 들을 사용하여 구현한'내가 만든 훅'
* 커스텀 훅은 비즈니스 로직을 모듈화 하고 여러 컴포넌트에서 재사용할 수 있는 추상화된 API를 제공하는 데 사용된다.


### 커스텀 훅 추출하기
* use로 시작하는 훅을 만들고 내부에서 다른 훅을 호출하면 안됨.


## 2024-04-17 강의 내용
* node_modules : 라이브러리 모음 폴더
* public : 이미지 파일과 같은 static 파일 보관함. 빌드 시에 압축되지 않음.
* src : 소스 코드 보관함
* src 폴더 안에 있는 App.js : 메인페이지에 들어갈 HTML을 작성하는 곳




### 훅이란 무엇인가?
* 클래스형 컴포넌트애서는 생성자에서 state를 정의하고 ,setState 함수를 통해 state를 업데이트 함.  
*    예전에 사용하던 함수형 컴포넌트는 별도로 state를 정의하거나 컴포넌트의 셍명주기에 맞춰서 어떤 코드가 실행되도록 할수 없엇음 
*    함수형 컴포넌트에서도 state나 생명주기 함수의 기능을 사용하게 해주기 위해 추가된 기능이 hook임   
 *   HOOK이란 state와 생명주기 기능에 갈고리를 걸어 원하는 시점에 정해진 함수를 실행되도록 만든 함수를 의미 
  *  훅의 이름은 모두  use로 시작함  


### useState
* useState는 함수형 컴포넌트에서 state를 사용하기 위한 Hook임  
``` 
const [state, setState] = useState(초기값);
```
### useEffect
* useState와 함께 가장 많이 사용하는 Hook임.
* 컴포넌트가 렌더링 될 때마다 특정 작업을 실행할 수 있도록 하는 Hook.
* useEffect는 component가 mount 됐을 때, component가 unmount 됐을 때, component가 update 됐을 때, 특정 작업을 처리할 수 있다.
* 첫번째 파라미터는 이펙트 함수가 들어가고, 두번째 파라미터로는 의존성 배열이 들어감 
* 즉, 클래스형 컴포넌트에서 사용할 수 있었던 생명주기 메소드를 함수형 컴포넌트에서도 사용할 수 있게 된 것이다.

### useMemo
* useMemo()혹은 Memoizde value를 리턴하는 훅임
* 이전 계산값을 갖고 있기 떄문에 연산량이 많은 작업의 반복을 피할 수 있슴
* 이 훅은 렌더링이 일어나는 동안 실행됨
* 따라서 렌더링이 일어나는 동안 실행돼서는 안될 작업을 넣으면 안됨
* 예를 들면 useEffect에서 실행되어야 할 사이드 이팩트 같은것임
```
const memoizedValue = useMemo(
    ()=> {
        //연산량이 높은 작업을 수행하여 결과를 반환
        return computerExopensiveValue(의존성 변수1, 의존성 변수2)

    },
    [의존성 변수1,의존성 변수2]
)
```

### useCallback
* useCallback()훅은 useMemo()와 유사한 역할을 함
* useMemo 는 특정 결과값을 재사용 할 때 사용하는 반면, useCallback 은 특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용합니다.




### userRef
* useRef()훅은 레퍼런스를 사용하기 위한 훅임
* 레퍼런스란 특정 컴포넌트에 접근할 수 있는 객체를 의미함
* useRef() 훅은 바로 이 레퍼런스 객체를 반환
* 레퍼런스 객체에는 .current라는 속성이 있는데, 이것은 현재 참조하고 있는 엘리먼트를 의미
* 즉 , 컴포넌트가 마운트 해제 전까지는 계속 유지된다는 의미
```
const refContainer = uesRef(초깃값)
```
### hook의 규칙
    최상위(at the Top Level)에서만 Hook을 호출해야 합니다
    오직 React 함수 내에서 Hook을 호출해야 합니다
    ESLint 플러그인

## 2024-04-03 강의 내용
### 컴포넌트에 대해 알아보기
1. 컴포넌트 구조라는 것은 작은 컴포넌트가 모여 큰 컴포넌트를 구성하고, 다시 이런 컴포넌트들이 모여서 전체 페이지를 구성한다는 것을 의미함.  
2. 컴포넌트는 재사용이 가능하기 떄문에 전체 코드의 양을 줄일 수 있어 개발 시간과 유지 보수 비용도 줄일 수 있음.  
3. 컴포넌트는 자바스크립트 함ㅅ처럼 입력과 출력이 있다는 면에서는 유사함  
4. 엘리먼트를 필요한 만큼 만들어 사용한다는 면에서는 객체 지향의 개념과 비슷함.  
### props에 대해 알아보기
1. props는 property (속성의) 준말.
2. 이 props가 바로 컴포넌트의 속성임.
3. 컴포넌트애 어떤 속성,props 를 넣느냐에 따라서 속성이 다른 엘리먼트가 출력됨.
4. props는 컴포넌트에 전달 할 다양한 정보를 담고 있는 자바스크립트 객체임.
#### props특징
1. 읽기 전용, 변경할 수 없다는 의미
2. 속성이 다른 엘리먼트를 생성하려면 새로운 props를 컴포넌트에 전달하면 됨.
#### Pure함수 Impure함수
* pure함수는 인수로 받은 정보가 함수 내부에서도 변하지 않는 함수.  
* impure함수는 인수로 받은 정보가 함수 내부에서 변하는 함수.
### 사용법
* JSX에서는 key-value쌍으로 props를 구성함

### 컴포넌트 만들기
1. 컴포넌트 종류
    * 리액트 초기 버전을 사용할 때는 클래스형 컴포넌트 주로 사용
    * 이후 hook이라는 개념이 나오면서 최근에는 함수형 컴포넌트를 주로 사용함
    * 예전에 작성된 코드나 문서들이 클래스형 컴포넌트를 사용하고 있기때문에, 클래스형 컴포넌트와 컴포넌트의 생명주기에 관해서도 공부해 두어야 함.

2. 함수형 컴포넌트
    * Welcome컴포넌트는 props를 받아, 받은 props중 name키의 값을 "안녕," 뒤에 넣어 반환함.  
3. 클래스형 컴포넌트
    * class 키워드 필요
    * Component로 상속을 받아야한다.
    * render() 메소드가 반드시 있어야한다.


4. 컴포넌트 이름짓기  
    * 이름은 항상 대문자로 시작
    * 리액트는 소문자로 시작하는 컴포넌트를 DOM태그로 인식하기 때문
    * 컴포넌트 파일 이름과 컴포넌트 이름은 같게 함

5. 컴포넌트 합성
    *컴포넌트 합성으     

6. state
    1. state란?
        * state는 리액트 컴포넌트의 상태를 의마함.
        * 상태의 의미는 정상인지 비정상인지가 아니라 컴포넌트의 데이터를 의마함.
        * 정확히는 컴포넌트의 변경가능한 데이터를 의미함.
        * State가 변하면 다시 렌더링이 되기 때문에 렌더링과 관련된 값만 state에 포함시켜야 함.
    2. 특징
        * 동일한 컴포넌트 두 군데에서 렌더링하면 각 컴포넌트는 완전히 독립된 state를 갖게 됩니다. 이 중 하나를 변경해도 다른 컴포넌트에는 영향을 미치지 않습니다.
        * state는 변경은 가능하다고 했지만 직접 수정해서는 안됨.
        * state를 변경하고자 할 때는 setstate() 를 사용.  

7. 생명주기에 대해 알아보기
    * 생명주기는 컴포넌트의 생성 시점, 사용 시점, 종료 시점을 나타내는 것이다.
    * constructor가 실행 되면서 컴포넌트가 실행됨.
    * 생성 직후 componentDidMount()함수가 호출됨.
    * 컴포넌트가 소멸하기 전까지 여러 번 랜더링 함.
    * 랜더링은 props,setState(), forceUpdateo()에 의해 상태가 변경되면 이루어짐.
    * 그리고 렌더링이 끝나면 componentDinUpdate()함수가 호출됨.
    * 마지막으로 컴포넌트가 언마운트 되면 compomentWillUnmount()함수가 호출됨.

    
## 2024-03-27 강의 내용
### JSX의 역할
1. JavaScript를 확장한 문법  
2. UI가 어떻게 생겨야 하는지 설명하기 위해 React와 함께 사용할 것을 권장함  
3. JSX라고 하면 템플릿 언어가 떠오를 수도 있지만, JavaScript의 모든 기능이 포함되어 있음  
4. 만일 JS작업할 경우 직접 createElement함수를 사용해야 함  

### 장점 
코드가 간결해짐
가독성이 향상
Injection Attack 으로 인해 보안이 강해짐

### JSX 사용법
1. 모든 자바스크립트 문법을 지원함  
2. 자바스크립트 문법에 XML과 HMTL 을 섞어서 사용  
3. 만일 html 과 xml 에 자바스크립트 코드를 사용하고 싶으면 {}를 사용함  
4. 실행 시키기 위해선 라이브러리를 바꿔줘야함  

### 엘리먼트
* 엘리먼트는 리액트 앱을 구성하는 요소  
* 웹사이트 경우는 DOM 엘리먼트이며 HTML요소를 의미함  

### 리액트 엘리먼트와 DOM엘리먼트 차이
리액트 엘리먼트는 Virtual VOM의 형태를 취하고있음  
DOM 엘리먼트는 페이지의 모든 정보를 갖고 있어 무거움  
반면 리액트 엘리먼트는 변화한 부분만 갖고 있어 가벼움  

### 엘리먼트의 생김새
리액트 엘리먼트는 자바스크립트 객체의 형태로 존재  
컴포넌트 속성 및 내부의 모든 children을 포함하는 일반 JS객체  
이 객체는 마음대로 변경할 수 없는 불변성을 갖고 있음  
내부적으로 자바스크립트 객체를 만드는 역할을 하는 함수가 createElement()

### 엘리먼트 특징
가장 큰 특징은 불변성  
즉, 한번 생성된 엘리먼트의 children이나 속성을 바꿀 수 없음  

### 만일 내용이 바뀌면?
이 떄는 컴포넌트를 통해 새로운 엘리먼트를 생성  
그 다음 이전 엘리먼트와 교체를 하는 방법으로 내용을 바꿈  
이렇게 교채허눈 적옵울 하기위해 Virtual DOM을 사용  

### 엘리먼트 렌더링하기
ROOT DOM node  
다음 html코드는 id 값이 root인 div태그로 단순하지만 리액트에 필수로 들어가는 아주 중요한 코드  
```
<div id ="root"></div>

const element = <h1>안녕, 리액트!</h1>;
ReactDOM.render(element,document.getElementById('root'));
```


## 2024-03-20 강의 내용
### react : 사용자 인터페이스를 만들기 위한 자바스크립트 라이브러리 <br>
복잡한 사이트를 쉽고 빠르게 만들고, 관리하기 위해 만들어진 것
다른 표현으로는 SPA를 쉽고 빠르게 만들 수있도록 해주는 도구  

### 장점
빠른 업데이트와 렌더링 속도 : virtual DOM(XML, GTML 문서의 각 항목을 계층으로 표현하여 생성, 변형, 삭제할 수 있도록 돕는 인터페이스)

1. 컴포넌트 기반 구조
리액트의 모든 페이지는 컴포넌트로 구성  
하나의 컴포넌트는 다른 여러개의 컴포넌트의 조합으로 구성  
블록의 조립하는 것처럼 컴포넌트를 조합해서 웹사이트 개발  
2. 재사용성
반복적인 작업을 줄여주기 때문에 생산성을 높여줌   
유지보수가 용이함  
재사용이 가능 하려면 해당 모듈의 의존성이 없어야 함  

3. 든든한 지원군
메타에서 오픈소스 프로젝트로 관리하고 있어 계속 발전  
4. 활발한 지식 공유
5. 모바일 앱 개발가능
리액트 네이티브라는 모바일 환경ui프레임워크를 사용하면 크로스 플랫폼 모바일 앱을 개발할 수 있음  
---
### 단점 
방대한 학습량  
높은 상태 관리 복잡도

### react 파일 생성 
`create-react-app

## 2024-03-13 강의 내용
### GitHub 사용법
깃허브 연동 방법
```
git config --global user.name "example"
git config --global user.email "example@example.com"
```
